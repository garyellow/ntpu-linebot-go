# https://taskfile.dev

version: '3'

vars:
  COVERAGE_FILE: coverage.out
  GOIMPORTS_VERSION: latest
  COVERAGE_THRESHOLD: 80

env:
  CGO_ENABLED: 0

tasks:
  # Development
  dev:
    desc: Run server in development mode
    env:
      LOG_LEVEL: debug
    cmds:
      - go run ./cmd/server

  # Testing
  test:
    desc: Run all tests (skipping network tests for faster CI)
    cmds:
      - go test -short -v -shuffle=on ./...

  test:full:
    desc: Run all tests including network tests (slower, for manual testing)
    cmds:
      - go test -v -shuffle=on ./...

  test:race:
    desc: Run tests with race detector, skipping network tests (requires CGO_ENABLED=1)
    env:
      CGO_ENABLED: 1
    cmds:
      - go test -short -v -race -shuffle=on ./...

  test:coverage:
    desc: Generate HTML coverage report with threshold check
    cmds:
      - go test -short -v -shuffle=on -coverprofile={{.COVERAGE_FILE}} -covermode=atomic ./...
      - go tool cover -html={{.COVERAGE_FILE}} -o coverage.html
      - go tool cover -func={{.COVERAGE_FILE}}
      - cmd: |
          $coverage = (go tool cover -func={{.COVERAGE_FILE}} | Select-String 'total:' | ForEach-Object { ($_ -split '\s+')[2] -replace '%','' })
          if ([float]$coverage -lt {{.COVERAGE_THRESHOLD}}) {
            Write-Host "Coverage $coverage% is below threshold {{.COVERAGE_THRESHOLD}}%" -ForegroundColor Red
            exit 1
          } else {
            Write-Host "Coverage $coverage% meets threshold {{.COVERAGE_THRESHOLD}}%" -ForegroundColor Green
          }
        platforms: [windows]
      - cmd: |
          coverage=$(go tool cover -func={{.COVERAGE_FILE}} | grep total | awk '{print $3}' | sed 's/%//')
          if [ $(echo "$coverage < {{.COVERAGE_THRESHOLD}}" | bc) -eq 1 ]; then
            echo "Coverage $coverage% is below threshold {{.COVERAGE_THRESHOLD}}%"
            exit 1
          else
            echo "Coverage $coverage% meets threshold {{.COVERAGE_THRESHOLD}}%"
          fi
        platforms: [linux, darwin]
      - echo "Coverage report -> coverage.html"

  test:coverage:race:
    desc: Generate HTML coverage report with race detector (requires CGO_ENABLED=1)
    env:
      CGO_ENABLED: 1
    cmds:
      - go test -short -v -race -shuffle=on -coverprofile={{.COVERAGE_FILE}} -covermode=atomic ./...
      - go tool cover -html={{.COVERAGE_FILE}} -o coverage.html
      - echo "Coverage report with race detector -> coverage.html"

  # Code Quality
  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run --timeout=5m ./...

  fmt:
    desc: Format and organize imports
    cmds:
      - go run golang.org/x/tools/cmd/goimports@{{.GOIMPORTS_VERSION}} -w .

  # Build
  build:
    desc: Build all binaries
    cmds:
      - go build -o bin/ ./cmd/...

  clean:
    desc: Clean build artifacts
    cmds:
      - cmd: rd /s /q bin 2>nul || exit 0
        platforms: [windows]
      - cmd: del coverage.out coverage.html 2>nul || exit 0
        platforms: [windows]
      - cmd: rm -rf bin/ coverage.out coverage.html
        platforms: [linux, darwin]
    ignore_error: true

  mod:
    desc: Tidy and verify dependencies
    cmds:
      - go mod tidy
      - go mod verify
      - go mod download

  vuln:
    desc: Check for known vulnerabilities
    cmds:
      - go run golang.org/x/vuln/cmd/govulncheck@latest -show verbose ./...

  # Docker Compose - Full Stack (Bot + Monitoring)
  compose:up:
    desc: Start full stack (Bot + Monitoring)
    dir: deployments/full
    cmds:
      - docker compose up -d

  compose:down:
    desc: Stop full stack
    dir: deployments/full
    cmds:
      - docker compose down

  compose:logs:
    desc: "View full stack logs (usage: task compose:logs -- SERVICE_NAME)"
    dir: deployments/full
    cmds:
      - docker compose logs -f {{.CLI_ARGS}}

  compose:update:
    desc: Update and restart full stack with latest images
    dir: deployments/full
    cmds:
      - docker compose pull
      - docker compose up -d

  compose:ps:
    desc: List full stack services status
    dir: deployments/full
    cmds:
      - docker compose ps

  compose:restart:
    desc: "Restart specific service (usage: task compose:restart -- SERVICE_NAME)"
    dir: deployments/full
    cmds:
      - docker compose restart {{.CLI_ARGS}}

  # Nginx Gateway for monitoring access
  access:up:
    desc: Open monitoring dashboard access (Grafana:3000, Prometheus:9090, Alertmanager:9093)
    dir: deployments/full/access
    cmds:
      - docker compose up -d

  access:down:
    desc: Close monitoring dashboard access (release ports)
    dir: deployments/full/access
    cmds:
      - docker compose down

  # Docker Compose - Monitoring Only (for external Bot)
  monitoring:up:
    desc: Start monitoring stack (for external Bot)
    dir: deployments/monitoring
    cmds:
      - docker compose up -d

  monitoring:down:
    desc: Stop monitoring stack
    dir: deployments/monitoring
    cmds:
      - docker compose down

  monitoring:logs:
    desc: "View monitoring logs (usage: task monitoring:logs -- SERVICE_NAME)"
    dir: deployments/monitoring
    cmds:
      - docker compose logs -f {{.CLI_ARGS}}

  # Nginx Gateway for monitoring access
  monitoring:access:up:
    desc: Open monitoring dashboard access
    dir: deployments/monitoring/access
    cmds:
      - docker compose up -d

  monitoring:access:down:
    desc: Close monitoring dashboard access (release ports)
    dir: deployments/monitoring/access
    cmds:
      - docker compose down

  # CI Pipeline
  ci:
    desc: Run full CI pipeline (mod + fmt + lint + test + vuln + build)
    deps: [mod]
    cmds:
      - task: fmt
      - task: lint
      - task: test
      - task: vuln
      - task: build
